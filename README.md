# COROUTINES- Coroutines is an instance of suspendible computation- It is similar to thread but its light weight than thread- coroutine is not bound to any particular thread. It may suspend its execution in one thread and resume in another one.## First Coroutines example```fun main() = runBlocking { // this: CoroutineScope    launch { // launch a new coroutine and continue        delay(1000L) // non-blocking delay for 1 second (default time unit is ms)        println("World!") // print after delay    }    println("Hello") // main coroutine continues while a previous one is delayed}```It will print```HelloWorld!```### Let us discuss the keywords used here to create coroutines- ### launch- is a coroutine builder. - It launches a new coroutine concurrently with the rest of the code, which continues to work independently. - That's why Hello has been printed first.- delay is a special suspending function. - It suspends the coroutine for a specific time. - Suspending a coroutine does not block the underlying thread, but allows other coroutines to run and use the underlying thread for their code.### runBlocking - is also a coroutine builder that bridges the non-coroutine world of a regular fun main() and the code with coroutines inside of runBlocking { ... } curly braces. - This is highlighted in an IDE by this: CoroutineScope hint right after the runBlocking opening curly brace.- If you remove or forget runBlocking in this code, you'll get an error on the launch call, since launch is declared only in the CoroutineScope:Unresolved reference: launch.====================== UDEMY COROUTINES=================- Coroutines= Coroutine Concept	- Scope	- suspending functions	- Jobs	- COntext- Exception Handling- Use of Coroutines- Threads are resource intensive -  it need resource to start stop- Coroutines are lightweight threads and uses thread pools- Simplify async code, callbacks and synchronisation- Simple syntax- Can pause and resume at any time, On a number of thread- **Scope** - Create and run coroutines, provides life cycle events- **Context** - The scope provides a context in which the coroutine runs- **Suspending function** - Functions that can be run in a coroutines- **Jobs**  a handle on coroutines- **Deferred** - a future result of a coroutine- **Dispatcher** - manages which thread(s) the coroutine runs onError handling1. runBlocking2. launch3. GlobalScope4. repeat### Scope- It provides lifecycle methods for coroutines- Allows us to start and stop coroutines- **GlobalScope.launch{}** - The scope of the coroutine is the lifecycle of entire application- **runBlocking** - Creates a scope and runs coroutines in a blocking way- **coroutineScope** - Creates a new scope does not complete until a children coroutines is complete```runBlocking{	launch{		delay(1000L)		println(“Hello”)	}}GlobalScope.launch{		delay(1000L)		println(“Hello”)}coroutineScope{		delay(1000L)		println(“Custom coroutinesScope”)}```### Context- A context is a set of data relates to coroutines- All coroutines have an associated context- You can start and stop coroutines- But context is the data associated with coroutines- Important elements of context- 1. Dispatcher - Which  thread the coroutines is run on- 2. Job - Handle on the coroutine lifecycle- If you explore GlobalScope, you can see coroutineScope and its use inside it### Suspending Function- A function that can be run in a coroutine- Make callbacks seamless```suspend fun sayHello(){	print(“”Hello)}GlobalScope.launch{	sayHello()}```### Jobs- A .launch() call returns a job- Allows us to manipulate the coroutine lifecycle- Live in the hierarchy of other jobs both as parents or children```job{	job{}job{	job{}	}	}``````val job1 = GlobalScope.launch{   	coroutineScope{   	val job2 = launch{   	// processing   }   }   }```- Can access lifecycle variables and methods- cancel()- join()- If a job is cancelled, all it’s parents and children will be cancelled too.### Dispatchers- A dispatcher determines which thread or thread pool the coroutine runs on- Different dispatchers are available depending on the task specificity```launch(Dispatchers.Default){	// do some cpu intensive processing task here}```## Common Dispatchers### 1. Main- Main thread update in UI driven applicaiton(eg Android)- Main dispatcher needs to be defined in grade### 2. Default- Useful for CPU intensive work### IO- useful for network communication or reading or writing files### Unconfined- Starts the coroutine in the inherited dispatcher that called it### newSingleThreadContext(“”MyThread)- Forces creation of a new thread- This is not used more often, because it more expensive and heavy## Async- Another way to start a coroutines- Just like launch, except it returns a result- In the form of a deferred- Deferred -  a future promise of a returned value- When we need the value, we call await() (blocking call)`	- If the value is available, it will return immediately	- If the value is not available, it will pause the thread until it is ```examplesuspend function getRandom() = Random.nextINt(1000)val valueDeffered = GlobalScope.async{	getRandom()}// DO ome processing hereval finalValue = valueDeffered(```## withContext- Allows us to easily change context- Easily switch between dispatchers- very Lightweight```launch(Dispatchers.Default){	// default contextwithCOntext(Dispatcher.IO){	// IO context	}// back to default context}```## Exception Handling in Coroutines-Exception behaviour depends on the coroutines builderlaunch- Propagates through the parent-child hierarchy- The exception will be thrown immediately and jobs will fail- use try-catch or an exception handler  - async	- Exceptions are deferred until the result is consumed	-   If the result is not consumed, the exception is never thrown	- try-catch in the coroutine or in the await() cal```val myHandler = CoroutineExceptionHandler { coroutineCOntext, throwable ->				// handle exception}launch(myHandler){	// do some task here	throws IndexOutOfBoundException()}```- If we want to pass Coroutine handler and also a Dispatcher then we can use like this```launch(Dispatchers.Default + myHandler){	// do some task here	throw IndexOutOfBoundException()}```## Sample Android Application for coroutines- Objectives	- Get an image from a URL	- Apply processing	- Show it in an ImageView- In this example we will create a CoroutineScope with using scope = main, because we have to update the image in main thread```private val coroutineScope = CoroutineScope(Dispatchers.Main)coroutineScope.launch {    val originalDeferred = coroutineScope.async(Dispatchers.IO) { getOriginalBitmap() } // This will download the image bitmap from the url    val originalBitmap = originalDeferred.await() // By calling this, it will wait until the result not getting    val filteredDeferred = coroutineScope.async(Dispatchers.Default) { applyFilter(originalBitmap) }  // another background task to apply the filter    val filteredBitmap = filteredDeferred.await() // in this line it will execute    loadImage(filteredBitmap)  // in this it will load the image to the Image view in the main thread}```- [Click here for Basic Example here](https://github.com/spdobest/CoroutinesWorld/tree/master/ImageProcessingCoroutines)## Another Example to use Coroutines with Retrofit in MVVM pattern- Get a list of country info from an endpoint- Use coroutines with Retrofit and MVVM- Show it in a RecyclerView- [Click here for Retrofit with Coroutines Example](https://github.com/spdobest/CoroutinesWorld/tree/master/AndroidCoroutinesRetrofit)## Coroutines, Room, MVVM- Objective of this prohject- Create, Read and delete data in a Room Database.- Use coroutines with Room and MVVM- Navigate in an app based on that data